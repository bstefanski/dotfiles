#!/usr/bin/env ruby

# setup:
# 1. gem install gitlab git
# 2. invoke in commandline `export GITLAB_API_PRIVATE_TOKEN={your private token}`
# and `export GITLAB_API_ENDPOINT={gitlab endpoint}`
#
# usage:
# gitlab-merge-request [assignee username]
# makes a merge request to default branch for the current branch that has
# already been pushed to origin

require "gitlab"
require "git"
require "tempfile"

GITLAB_BASE_URL = ENV['GITLAB_API_ENDPOINT'].sub '/api/v3', ''
@assignee_username = ARGV[0]
@git = Git.open(Dir.pwd)

def parse_remote_url(url)
  m = url.match(%r{:(.*)/(.*)\.git})
  { namespace: m[1], path: m[2] }
end

def find_gitlab_project(namespace, path)
    #fallback: looking for projects with corresponding namespace
    projects = Gitlab.projects({'search': namespace})

    if not projects.any?
      raise sprintf("Unable find project with namespace '%s' and path '%s'", namespace, path)
    end

  path_with_namespace = namespace + '/' + path

  #only return the right one (same namespace and path)
  projects.detect { |proj| proj.path_with_namespace == path_with_namespace }
end

def cwd_gitlab_project
  project = parse_remote_url @git.config['remote.origin.url']
  find_gitlab_project project[:namespace], project[:path]
end

def format_url(*args)
  "#{GITLAB_BASE_URL}/#{args.join '/'}"
end

def assignee_id(assignee_username)
  Gitlab.users(per_page: 100).find {|i| i.username.include? assignee_username}.id
end

current_branch = @git.branches.find(&:current).name
project = cwd_gitlab_project

params = {
  :source_branch => current_branch,
  :target_branch => 'default',
  :assignee_id => assignee_id(@assignee_username)
}.reject { |k,v| v.nil? }

merge_request =  Gitlab.create_merge_request project.id, current_branch, params

puts format_url project.path_with_namespace, 'merge_requests' , merge_request.iid
